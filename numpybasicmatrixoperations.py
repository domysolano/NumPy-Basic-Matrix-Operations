# -*- coding: utf-8 -*-
"""NumPyBasicMatrixOperations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cMrx0DiEjcKWOQIzoN4boA9GlelV3HFh

**Maestría en Inteligencia Artificial y Analítica de Datos**

Curso: *Programación para Analítica Descriptiva y Predictiva*

* Semestre: Enero-Junio 2026
* Profesor: Dr. Vicente García Jiménez
* Alumno: Ricardo Solano Monje
* Matrícula: 266221
* Unidad 1
* Práctica 4: Manipulación de matrices
* Objetivo de la práctica: Usar NumPy para crear matrices y realizar algunas operaciones básicas sobre éstas.
* Programa realizado por: Ricardo Solano Monje

# NumPy: *Basic Matrix Operations*

### Manipulación de matrices.

* Crea dos matrices de 3x3 con números aleatorios entre 1 y 10. *Realiza las siguientes operaciones:*
  * Suma ambas matrices.
  * Resta la segunda matriz de la primera.
  * Multiplica la primera matriz por 2.
  * Realiza una multiplicación matricial entre las dos matrices.

## Broadcasting in NumPy.

Thanks to NumPy, Array Operations is where Python becomes magic. *Broadcasting is NumPy-specific* (regular Python lists DON'T support broadcasting) but follows Python's philosophy of making *common operations easy and intuitive*. However, it's not a general Python language feature.

### What is Broadcasting?
Broadcasting allows NumPy to perform operations on arrays of different shapes by "stretching" the smaller array to match the larger one's shape.

In NumPy, the operation result = array + 10 (where array is [1, 2, 3, 4])
uses broadcasting to add the scalar value \(10\) to every element of the array.
It does this by conceptually "stretching" the scalar into an array of the same shape as the original array,
enabling efficient, element-wise addition.

### The Broadcasting Rules

NumPy follows strict rules for broadcasting. Two arrays are broadcastable if:

* Rule 1: Dimensions are aligned from the RIGHT.
* Rule 2: Dimensions must be equal OR one of them must be 1
* Rule 3: Missing dimensions are treated as 1
"""

import numpy as np
print("NumPy version:", np.__version__)

"""### I. Create Two 3x3 Matrices with random numbers between 1 and 100"""

### Create Two 3x3 Matrices with Random Numbers (1-10) (inclusive)
# Set random seed for reproducibility
np.random.seed(42)
# Create A matrix 3x3
matrixA = np.random.randint(1, 11, size=(3, 3))
print(f"Matrix A {matrixA.shape}:")
print(matrixA)
print()

# Create B matrix 3x3
matrixB = np.random.randint(1, 11, size=(3, 3))
print(f"Matrix B {matrixB.shape}:")
print(matrixB)

"""## *II. Carry out the following Operations:*

* *1: Add both matrices.*
"""

print("1. Matrix Addition C=(A + B)")
print("Matrix A:")
print(matrixA)
print("\nMatrix B:")
print(matrixB)

# Element-wise addition
matrixC = matrixA + matrixB
print("\nMatrix C= (A + B):")
print(matrixC)

# Visual computing
print("\nVisual computing C:")
for i in range(3):
    for j in range(3):
        print(f"  {matrixC[i,j]:3d} = {matrixA[i,j]:2d} + {matrixB[i,j]:2d}  ", end="  ")
    print()

"""* *2: Subtract the second matrix from the first one, C=(A - B)*"""

print("2. Matrix Subtraction C=(A - B)")
print("Matrix A:")
print(matrixA)
print("\nMatrix B:")
print(matrixB)

# Element-wise subtraction
matrixC = matrixA - matrixB
print("\nC=(A - B):")
print(matrixC)

# Visual representation
print("\nVisual computing C:")
for i in range(3):
    for j in range(3):
        print(f"  {matrixC[i,j]:3d}={matrixA[i,j]:2d} - {matrixB[i,j]:2d} ", end="  ")
    print()

"""* *3. Multiply First Matrix by 2*

Scalar multiplication C=2*A IS broadcasting, but it's the simplest form of broadcasting.
"""

# For Broadcasting the operation to all elements of the matrix, just times 2, NumPy will do the job

print("3. Scalar Multiplication C=2*A")
print("Matrix A:")
print(matrixA)
# Scalar multiplication using broadcast propagation.
matrixC = matrixA * 2
print("\nC=2*A:")
print(matrixC)

# Using np.multiply() method
matrixC2 = np.multiply(matrixA, 2)
print("\nUsing np.multiply(matrixA, 2):")
print(matrixC2)

# Verifying same results using boolean match
print(f"\nare results identical?: {np.array_equal(matrixC, matrixC2)}")

"""* *4: Perform a matrix multiplication between the two matrices.*"""

print("=== 4. Matrix Multiplication (A · B) ===")
print("Matrix A:")
print(matrixA)
print("\nMatrix B:")
print(matrixB)

# Matrix multiplication (dot product)
matrixC = np.dot(matrixA, matrixB)
print("\nC=(A · B):")
print(matrixC)

# Alternative method using @ operator, it acts as operator overloading, easier to read in math formulas!
matrixC2 = matrixA @ matrixB
print("\nUsing @ operator: C= (A @ B)")
print(matrixC2)

# Manual calculation explanation
print("\n=== How Matrix Multiplication Works ===")
print("For a 3x3 matrix multiplication C = A · B:")
print("C[i,j] = A[i,0]×B[0,j] + A[i,1]×B[1,j] + A[i,2]×B[2,j]")
print()

# Show calculation for first element
print("Example: Calculating C[0,0]:")
a_row = matrixA[0, :]  # First row of A
b_col = matrixB[:, 0]  # First column of B
print(f"  A[0,:] = {a_row}")
print(f"  B[:,0] = {b_col}")
c_00 = np.dot(a_row, b_col)
print(f"  C[0,0] = ({a_row[0]}×{b_col[0]}) + ({a_row[1]}×{b_col[1]}) + ({a_row[2]}×{b_col[2]})")
print(f"        = {a_row[0]*b_col[0]} + {a_row[1]*b_col[1]} + {a_row[2]*b_col[2]}")
print(f"        = {c_00}")
print(f"  From result matrix: {matrixC[0,0]}")

